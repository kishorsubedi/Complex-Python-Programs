# Class Queue to represent a queue 
class queue: 
  
    # __init__ function 
    def __init__(self, capacity): 
        self.front = self.size = 0
        self.rear = capacity -1
        self.Q = [None]*capacity 
        self.capacity = capacity 
      
    # Queue is full when size becomes 
    # equal to the capacity  
    def isFull(self): 
        return self.size == self.capacity 
      
    # Queue is empty when size is 0 
    def isEmpty(self): 
        return self.size == 0
  
    # Function to add an item to the queue.  
    # It changes rear and size 
    def EnQueue(self, item): 
        if self.isFull(): 
            print("Full") 
            return
        self.rear = (self.rear + 1) % (self.capacity) 
        self.Q[self.rear] = item 
        self.size = self.size + 1
        #print("%s enqueued to queue"  %str(item)) 
  
    # Function to remove an item from queue.  
    # It changes front and size 
    def DeQueue(self): 
        if self.isEmpty(): 
            print("Empty") 
            return
          
        #print("%s dequeued from queue" %str(self.Q[self.front])) 
        x = self.Q[self.front]
        self.front = (self.front + 1) % (self.capacity) 
        self.size = self.size -1
        return x
          
    # Function to get front of queue 
    def que_front(self): 
        if self.isEmpty(): 
            print("Queue is empty") 
  
        print("Front item is", self.Q[self.front]) 
          
    # Function to get rear of queue 
    def que_rear(self): 
        if self.isEmpty(): 
            print("Queue is empty") 
        print("Rear item is",  self.Q[self.rear]) 
  
def file_path_to_inst_array(nfa_file):
    nfa_file = open(nfa_file, "r")
    p = ""
    for each in nfa_file:
        p = p + each 
    return p.split("\n")

def putinqueue(q, qset, inst_index):
    if(inst_index not in qset):
        qset.add(inst_index)
        q.EnQueue(inst_index)
    return q 

def method(instruction_array, input_text, char_index, pc_tc_match):
    match = False
    max_index = char_index
    max_match_pc = 0
    clist = queue(len(instruction_array))
    clistset = set()

    nlist = queue(len(instruction_array))
    nlistset = set()

    putinqueue(clist, clistset, 0)
    while(len(clistset) != 0 and char_index <= len(input_text)):
        while(len(clistset) != 0):

            pc = clist.DeQueue()
            clistset.remove(pc)
            instruction = instruction_array[int(pc)].split(" ")
            inst_opcode = instruction[1]
            
            if(inst_opcode == "CHAR"):#range 
                if(char_index == len(input_text)):
                    continue
                for i in range(int(instruction[2]) , int(instruction[3])+1 ):
                    if(i == ord(input_text[char_index]) ):
                        putinqueue(nlist, nlistset, pc+1)
                        break

            elif(inst_opcode == "JMP"):
                putinqueue(clist, clistset, instruction[2])

            elif(inst_opcode == "MATCH"):
                if(char_index > max_index):
                    max_index = char_index
                    max_match_pc = pc
                    match = True
                if(char_index == len(input_text)):
                    #print("Match at PC", max_match_pc, "for tc until(exclusive)", max_index)
                    pc_tc_match.append([max_match_pc, max_index])
                    return max_index
            else:
                putinqueue(clist, clistset, int(instruction[2]))
                putinqueue(clist, clistset, int(instruction[3]))
        clist = nlist
        clistset = nlistset 
        nlist = queue(len(instruction_array))
        nlistset = set() 
        char_index +=1

    if(match == False):
        return 0 
    else:
        #print("Match at PC", max_match_pc, "for tc until(exclusive)", max_index)
        pc_tc_match.append([max_match_pc, max_index])
        return max_index
    
def showformattedoutput(input_text, PC_TC_MATCH):
    indx = 0
    for each in PC_TC_MATCH:
        print('{}:"{}"'.format(each[0], input_text[indx:each[1]]) )
        indx = each[1]

#def thompsonvm(input_text, nfa_instruction_file):
def thompsonvm(input_text, instruction_array):
    #instruction_array = file_path_to_inst_array(nfa_instruction_file)
    #return instruction_array
    main_matches = []
    PC_INDEX_MATCH = []

    char_index = 0
    while(char_index < len(input_text)):
        
        returned = method(instruction_array, input_text, char_index, PC_INDEX_MATCH)#2
        if(returned == 0):
            return 1
        char_index = returned#2
    showformattedoutput(input_text, PC_INDEX_MATCH)
    return 0
   
a = ['0 SPLIT 1 6', '1 CHAR 97 97', '2 SPLIT 3 5', '3 CHAR 97 97', '4 JMP 2', '5 MATCH', '6 SPLIT 7 9', '7 CHAR 97 97', '8 MATCH', '9 SPLIT 10 12', '10 CHAR 32 32', '11 JMP 16', '12 SPLIT 13 15', '13 CHAR 9 9', '14 JMP 16', '15 CHAR 10 10', '16 SPLIT 17 25', '17 SPLIT 18 20', '18 CHAR 32 32', '19 JMP 24', '20 SPLIT 21 23', '21 CHAR 9 9', '22 JMP 24', '23 CHAR 10 10', '24 JMP 16', '25 MATCH']
print(thompsonvm("a aa a aaaa a aaaa a", a))
